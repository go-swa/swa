var TokenStream = require('../common/TokenStream');
var adoptBuffer = require('../common/adopt-buffer');

var constants = require('./const');
var TYPE = constants.TYPE;

var charCodeDefinitions = require('./char-code-definitions');
var isNewline = charCodeDefinitions.isNewline;
var isName = charCodeDefinitions.isName;
var isValidEscape = charCodeDefinitions.isValidEscape;
var isNumberStart = charCodeDefinitions.isNumberStart;
var isIdentifierStart = charCodeDefinitions.isIdentifierStart;
var charCodeCategory = charCodeDefinitions.charCodeCategory;
var isBOM = charCodeDefinitions.isBOM;

var utils = require('./utils');
var cmpStr = utils.cmpStr;
var getNewlineLength = utils.getNewlineLength;
var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
var consumeEscaped = utils.consumeEscaped;
var consumeName = utils.consumeName;
var consumeNumber = utils.consumeNumber;
var consumeBadUrlRemnants = utils.consumeBadUrlRemnants;

var OFFSET_MASK = 0x00FFFFFF;
var TYPE_SHIFT = 24;

function tokenize(source, stream) {
    function getCharCode(offset) {
        return offset < sourceLength ? source.charCodeAt(offset) : 0;
    }

    function consumeNumericToken() {
        offset = consumeNumber(source, offset);

        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
            type = TYPE.Dimension;
            offset = consumeName(source, offset);
            return;
        }

        if (getCharCode(offset) === 0x0025) {
            type = TYPE.Percentage;
            offset++;
            return;
        }

        type = TYPE.Number;
    }

    function consumeIdentLikeToken() {
        const nameStartOffset = offset;

        offset = consumeName(source, offset);

        if (cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
            offset = findWhiteSpaceEnd(source, offset + 1);

            if (getCharCode(offset) === 0x0022 ||
                getCharCode(offset) === 0x0027) {
                type = TYPE.Function;
                offset = nameStartOffset + 4;
                return;
            }

            consumeUrlToken();
            return;
        }

        if (getCharCode(offset) === 0x0028) {
            type = TYPE.Function;
            offset++;
            return;
        }

        type = TYPE.Ident;
    }

    function consumeStringToken(endingCodePoint) {
        if (!endingCodePoint) {
            endingCodePoint = getCharCode(offset++);
        }

        type = TYPE.String;

        for (; offset < source.length; offset++) {
            var code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                case endingCodePoint:
                    offset++;
                    return;

                case charCodeCategory.Eof:
                    return;

                case charCodeCategory.WhiteSpace:
                    if (isNewline(code)) {
                        offset += getNewlineLength(source, offset, code);
                        type = TYPE.BadString;
                        return;
                    }
                    break;

                case 0x005C:
                    if (offset === source.length - 1) {
                        break;
                    }

                    var nextCode = getCharCode(offset + 1);

                    if (isNewline(nextCode)) {
                        offset += getNewlineLength(source, offset + 1, nextCode);
                    } else if (isValidEscape(code, nextCode)) {
                        offset = consumeEscaped(source, offset) - 1;
                    }
                    break;

            }
        }
    }

    function consumeUrlToken() {
        type = TYPE.Url;

        offset = findWhiteSpaceEnd(source, offset);

        for (; offset < source.length; offset++) {
            var code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                case 0x0029:
                    offset++;
                    return;

                case charCodeCategory.Eof:
                    return;

                case charCodeCategory.WhiteSpace:
                    offset = findWhiteSpaceEnd(source, offset);

                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
                        if (offset < source.length) {
                            offset++;
                        }
                        return;
                    }

                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE.BadUrl;
                    return;

                case 0x0022:
                case 0x0027:
                case 0x0028:
                case charCodeCategory.NonPrintable:
                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE.BadUrl;
                    return;

                case 0x005C:
                    if (isValidEscape(code, getCharCode(offset + 1))) {
                        offset = consumeEscaped(source, offset) - 1;
                        break;
                    }

                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE.BadUrl;
                    return;

            }
        }
    }

    if (!stream) {
        stream = new TokenStream();
    }

    source = String(source || '');

    var sourceLength = source.length;
    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
    var balance = adoptBuffer(stream.balance, sourceLength + 1);
    var tokenCount = 0;
    var start = isBOM(getCharCode(0));
    var offset = start;
    var balanceCloseType = 0;
    var balanceStart = 0;
    var balancePrev = 0;

    while (offset < sourceLength) {
        var code = source.charCodeAt(offset);
        var type = 0;

        balance[tokenCount] = sourceLength;

        switch (charCodeCategory(code)) {
            case charCodeCategory.WhiteSpace:
                type = TYPE.WhiteSpace;
                offset = findWhiteSpaceEnd(source, offset + 1);
                break;

            case 0x0022:
                consumeStringToken();
                break;

            case 0x0023:
                if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
                    type = TYPE.Hash;


                    offset = consumeName(source, offset + 1);

                } else {
                    type = TYPE.Delim;
                    offset++;
                }

                break;

            case 0x0027:
                consumeStringToken();
                break;

            case 0x0028:
                type = TYPE.LeftParenthesis;
                offset++;
                break;

            case 0x0029:
                type = TYPE.RightParenthesis;
                offset++;
                break;

            case 0x002B:
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    consumeNumericToken();
                } else {
                    type = TYPE.Delim;
                    offset++;
                }
                break;

            case 0x002C:
                type = TYPE.Comma;
                offset++;
                break;

            case 0x002D:
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    consumeNumericToken();
                } else {
                    if (getCharCode(offset + 1) === 0x002D &&
                        getCharCode(offset + 2) === 0x003E) {
                        type = TYPE.CDC;
                        offset = offset + 3;
                    } else {
                        if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                            consumeIdentLikeToken();
                        } else {
                            type = TYPE.Delim;
                            offset++;
                        }
                    }
                }
                break;

            case 0x002E:
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    consumeNumericToken();
                } else {
                    type = TYPE.Delim;
                    offset++;
                }

                break;

            case 0x002F:
                if (getCharCode(offset + 1) === 0x002A) {
                    type = TYPE.Comment;
                    offset = source.indexOf('*/', offset + 2) + 2;
                    if (offset === 1) {
                        offset = source.length;
                    }
                } else {
                    type = TYPE.Delim;
                    offset++;
                }
                break;

            case 0x003A:
                type = TYPE.Colon;
                offset++;
                break;

            case 0x003B:
                type = TYPE.Semicolon;
                offset++;
                break;

            case 0x003C:
                if (getCharCode(offset + 1) === 0x0021 &&
                    getCharCode(offset + 2) === 0x002D &&
                    getCharCode(offset + 3) === 0x002D) {
                    type = TYPE.CDO;
                    offset = offset + 4;
                } else {
                    type = TYPE.Delim;
                    offset++;
                }

                break;

            case 0x0040:
                if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    type = TYPE.AtKeyword;
                    offset = consumeName(source, offset + 1);
                } else {
                    type = TYPE.Delim;
                    offset++;
                }

                break;

            case 0x005B:
                type = TYPE.LeftSquareBracket;
                offset++;
                break;

            case 0x005C:
                if (isValidEscape(code, getCharCode(offset + 1))) {
                    consumeIdentLikeToken();
                } else {
                    type = TYPE.Delim;
                    offset++;
                }
                break;

            case 0x005D:
                type = TYPE.RightSquareBracket;
                offset++;
                break;

            case 0x007B:
                type = TYPE.LeftCurlyBracket;
                offset++;
                break;

            case 0x007D:
                type = TYPE.RightCurlyBracket;
                offset++;
                break;

            case charCodeCategory.Digit:
                consumeNumericToken();
                break;

            case charCodeCategory.NameStart:
                consumeIdentLikeToken();
                break;

            case charCodeCategory.Eof:
                break;

            default:
                type = TYPE.Delim;
                offset++;
        }

        switch (type) {
            case balanceCloseType:
                balancePrev = balanceStart & OFFSET_MASK;
                balanceStart = balance[balancePrev];
                balanceCloseType = balanceStart >> TYPE_SHIFT;
                balance[tokenCount] = balancePrev;
                balance[balancePrev++] = tokenCount;
                for (; balancePrev < tokenCount; balancePrev++) {
                    if (balance[balancePrev] === sourceLength) {
                        balance[balancePrev] = tokenCount;
                    }
                }
                break;

            case TYPE.LeftParenthesis:
            case TYPE.Function:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE.RightParenthesis;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;

            case TYPE.LeftSquareBracket:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE.RightSquareBracket;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;

            case TYPE.LeftCurlyBracket:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE.RightCurlyBracket;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;
        }

        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
    }

    offsetAndType[tokenCount] = (TYPE.EOF << TYPE_SHIFT) | offset; // <EOF-token>
    balance[tokenCount] = sourceLength;
    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
    while (balanceStart !== 0) {
        balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
    }

    stream.source = source;
    stream.firstCharOffset = start;
    stream.offsetAndType = offsetAndType;
    stream.tokenCount = tokenCount;
    stream.balance = balance;
    stream.reset();
    stream.next();

    return stream;
}

Object.keys(constants).forEach(function(key) {
    tokenize[key] = constants[key];
});

Object.keys(charCodeDefinitions).forEach(function(key) {
    tokenize[key] = charCodeDefinitions[key];
});
Object.keys(utils).forEach(function(key) {
    tokenize[key] = utils[key];
});

module.exports = tokenize;
