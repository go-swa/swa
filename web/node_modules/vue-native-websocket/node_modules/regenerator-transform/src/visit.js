/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

"use strict";

import assert from "assert";
import * as t from "babel-types";
import { hoist } from "./hoist";
import { Emitter } from "./emit";
import replaceShorthandObjectMethod from "./replaceShorthandObjectMethod";
import * as util from "./util";

exports.visitor = {
  Function: {
    exit: function(path, state) {
      let node = path.node;

      if (node.generator) {
        if (node.async) {
          if (state.opts.asyncGenerators === false) return;
        } else {
          if (state.opts.generators === false) return;
        }
      } else if (node.async) {
        if (state.opts.async === false) return;
      } else {
        return;
      }

      path = replaceShorthandObjectMethod(path);
      node = path.node;

      let contextId = path.scope.generateUidIdentifier("context");
      let argsId = path.scope.generateUidIdentifier("args");

      path.ensureBlock();
      let bodyBlockPath = path.get("body");

      if (node.async) {
        bodyBlockPath.traverse(awaitVisitor);
      }

      bodyBlockPath.traverse(functionSentVisitor, {
        context: contextId
      });

      let outerBody = [];
      let innerBody = [];

      bodyBlockPath.get("body").forEach(function(childPath) {
        let node = childPath.node;
        if (t.isExpressionStatement(node) &&
            t.isStringLiteral(node.expression)) {
          outerBody.push(node);
        } else if (node && node._blockHoist != null) {
          outerBody.push(node);
        } else {
          innerBody.push(node);
        }
      });

      if (outerBody.length > 0) {
        bodyBlockPath.node.body = innerBody;
      }

      let outerFnExpr = getOuterFnExpr(path);
      t.assertIdentifier(node.id);
      let innerFnId = t.identifier(node.id.name + "$");

      let vars = hoist(path);

      let didRenameArguments = renameArguments(path, argsId);
      if (didRenameArguments) {
        vars = vars || t.variableDeclaration("var", []);
        const argumentIdentifier = t.identifier("arguments");
        argumentIdentifier._shadowedFunctionLiteral = path;
        vars.declarations.push(t.variableDeclarator(
          argsId, argumentIdentifier
        ));
      }

      let emitter = new Emitter(contextId);
      emitter.explode(path.get("body"));

      if (vars && vars.declarations.length > 0) {
        outerBody.push(vars);
      }

      let wrapArgs = [
        emitter.getContextFunction(innerFnId),
        node.generator ? outerFnExpr : t.nullLiteral(),
        t.thisExpression()
      ];

      let tryLocsList = emitter.getTryLocsList();
      if (tryLocsList) {
        wrapArgs.push(tryLocsList);
      }

      let wrapCall = t.callExpression(
        util.runtimeProperty(node.async ? "async" : "wrap"),
        wrapArgs
      );

      outerBody.push(t.returnStatement(wrapCall));
      node.body = t.blockStatement(outerBody);

      const oldDirectives = bodyBlockPath.node.directives;
      if (oldDirectives) {
        node.body.directives = oldDirectives;
      }

      let wasGeneratorFunction = node.generator;
      if (wasGeneratorFunction) {
        node.generator = false;
      }

      if (node.async) {
        node.async = false;
      }

      if (wasGeneratorFunction && t.isExpression(node)) {
        util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty("mark"), [node]))
        path.addComment("leading", "#__PURE__");
      }

      path.requeue();
    }
  }
};

function getOuterFnExpr(funPath) {
  let node = funPath.node;
  t.assertFunction(node);

  if (!node.id) {
    node.id = funPath.scope.parent.generateUidIdentifier("callee");
  }

  if (node.generator && // Non-generator functions don't need to be marked.
      t.isFunctionDeclaration(node)) {
    return getMarkedFunctionId(funPath);
  }

  return node.id;
}

const getMarkInfo = require("private").makeAccessor();

function getMarkedFunctionId(funPath) {
  const node = funPath.node;
  t.assertIdentifier(node.id);

  const blockPath = funPath.findParent(function (path) {
    return path.isProgram() || path.isBlockStatement();
  });

  if (!blockPath) {
    return node.id;
  }

  const block = blockPath.node;
  assert.ok(Array.isArray(block.body));

  const info = getMarkInfo(block);
  if (!info.decl) {
    info.decl = t.variableDeclaration("var", []);
    blockPath.unshiftContainer("body", info.decl);
    info.declPath = blockPath.get("body.0");
  }

  assert.strictEqual(info.declPath.node, info.decl);

  const markedId = blockPath.scope.generateUidIdentifier("marked");
  const markCallExp = t.callExpression(
    util.runtimeProperty("mark"),
    [node.id]
  );

  const index = info.decl.declarations.push(
    t.variableDeclarator(markedId, markCallExp)
  ) - 1;

  const markCallExpPath =
    info.declPath.get("declarations." + index + ".init");

  assert.strictEqual(markCallExpPath.node, markCallExp);

  markCallExpPath.addComment("leading", "#__PURE__");

  return markedId;
}

function renameArguments(funcPath, argsId) {
  let state = {
    didRenameArguments: false,
    argsId: argsId
  };

  funcPath.traverse(argumentsVisitor, state);

  return state.didRenameArguments;
}

let argumentsVisitor = {
  "FunctionExpression|FunctionDeclaration": function(path) {
    path.skip();
  },

  Identifier: function(path, state) {
    if (path.node.name === "arguments" && util.isReference(path)) {
      util.replaceWithOrRemove(path, state.argsId);
      state.didRenameArguments = true;
    }
  }
};

let functionSentVisitor = {
  MetaProperty(path) {
    let { node } = path;

    if (node.meta.name === "function" && node.property.name === "sent") {
      util.replaceWithOrRemove(path, t.memberExpression(this.context, t.identifier("_sent")));
    }
  }
};

let awaitVisitor = {
  Function: function(path) {
    path.skip(); // Don't descend into nested function scopes.
  },

  AwaitExpression: function(path) {
    let argument = path.node.argument;

    util.replaceWithOrRemove(path, t.yieldExpression(
      t.callExpression(
        util.runtimeProperty("awrap"),
        [argument]
      ),
      false
    ));
  }
};
