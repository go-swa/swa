
/*globals setTimeout, define, module */

(function (globals) {
  'use strict';

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return tryer;
    });
  } else if (typeof module !== 'undefined' && module !== null) {
    module.exports = tryer;
  } else {
    globals.tryer = tryer;
  }

  function tryer (options) {
    options = normaliseOptions(options);

    iterateWhen();

    function iterateWhen () {
      if (preRecur()) {
        iterateUntil();
      }
    }

    function preRecur () {
      return conditionallyRecur('when', iterateWhen);
    }

    function conditionallyRecur (predicateKey, iterate) {
      if (! options[predicateKey]()) {
        incrementCount(options);

        if (shouldFail(options)) {
          options.fail();
        }  else {
          recur(iterate, postIncrementInterval(options));
        }

        return false;
      }

      return true;
    }

    function iterateUntil () {
      var result;

      if (isActionSynchronous(options)) {
        result = options.action();

        if (result && isFunction(result.then)) {
          return result.then(postRecur, postRecur);
        }

        return postRecur();
      }

      options.action(postRecur);
    }

    function postRecur () {
      if (conditionallyRecur('until', iterateUntil)) {
        options.pass();
      }
    }
  }

  function normaliseOptions (options) {
    options = options || {};
    return {
      count: 0,
      when: normalisePredicate(options.when),
      until: normalisePredicate(options.until),
      action: normaliseFunction(options.action),
      fail: normaliseFunction(options.fail),
      pass: normaliseFunction(options.pass),
      interval: normaliseNumber(options.interval, -1000),
      limit: normaliseNumber(options.limit, -1)
    };
  }

  function normalisePredicate (fn) {
    return normalise(fn, isFunction, yes);
  }

  function isFunction (fn) {
    return typeof fn === 'function';
  }

  function yes () {
    return true;
  }

  function normaliseFunction (fn) {
    return normalise(fn, isFunction, nop);
  }

  function nop () {
  }

  function normalise (thing, predicate, defaultValue) {
    if (predicate(thing)) {
      return thing;
    }

    return defaultValue;
  }

  function normaliseNumber (number, defaultNumber) {
    return normalise(number, isNumber, defaultNumber);
  }

  function isNumber (number) {
    return typeof number === 'number' && number === number;
  }

  function isActionSynchronous (options) {
    return options.action.length === 0;
  }

  function incrementCount (options) {
    options.count += 1;
  }

  function shouldFail (options) {
    return options.limit >= 0 && options.count >= options.limit;
  }

  function postIncrementInterval (options) {
    var currentInterval = options.interval;

    if (options.interval < 0) {
      options.interval *= 2;
    }

    return currentInterval;
  }

  function recur (fn, interval) {
    setTimeout(fn, Math.abs(interval));
  }
}(this));

