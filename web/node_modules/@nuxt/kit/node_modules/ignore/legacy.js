"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function makeArray(subject) {
  return Array.isArray(subject) ? subject : [subject];
}
var EMPTY = '';
var SPACE = ' ';
var ESCAPE = '\\';
var REGEX_TEST_BLANK_LINE = /^\s+$/;
var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
var REGEX_SPLITALL_CRLF = /\r?\n/g;
var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
var SLASH = '/';

var TMP_KEY_IGNORE = 'node-ignore';
/* istanbul ignore else */
if (typeof Symbol !== 'undefined') {
  TMP_KEY_IGNORE = Symbol["for"]('node-ignore');
}
var KEY_IGNORE = TMP_KEY_IGNORE;
var define = function define(object, key, value) {
  return Object.defineProperty(object, key, {
    value: value
  });
};
var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
var RETURN_FALSE = function RETURN_FALSE() {
  return false;
};

var sanitizeRange = function sanitizeRange(range) {
  return range.replace(REGEX_REGEXP_RANGE, function (match, from, to) {
    return from.charCodeAt(0) <= to.charCodeAt(0) ? match
    : EMPTY;
  });
};

var cleanRangeBackSlash = function cleanRangeBackSlash(slashes) {
  var length = slashes.length;
  return slashes.slice(0, length - length % 2);
};


var REPLACERS = [
[
/\\?\s+$/, function (match) {
  return match.indexOf('\\') === 0 ? SPACE : EMPTY;
}],
[/\\\s/g, function () {
  return SPACE;
}],

[/[\\$.|*+(){^]/g, function (match) {
  return "\\".concat(match);
}], [
/(?!\\)\?/g, function () {
  return '[^/]';
}],
[
/^\//, function () {
  return '^';
}],
[/\//g, function () {
  return '\\/';
}], [
/^\^*\\\*\\\*\\\//,
function () {
  return '^(?:.*\\/)?';
}],
[
/^(?=[^^])/, function startingReplacer() {
  return !/\/(?!$)/.test(this)

  ? '(?:^|\\/)'

  : '^';
}],
[
/\\\/\\\*\\\*(?=\\\/|$)/g,

function (_, index, str) {
  return index + 6 < str.length

  ? '(?:\\/[^\\/]+)*'


  : '\\/.+';
}],
[

/(^|[^\\]+)(\\\*)+(?=.+)/g,
function (_, p1, p2) {
  var unescaped = p2.replace(/\\\*/g, '[^\\/]*');
  return p1 + unescaped;
}], [
/\\\\\\(?=[$.|*+(){^])/g, function () {
  return ESCAPE;
}], [
/\\\\/g, function () {
  return ESCAPE;
}], [

/(\\)?\[([^\]/]*?)(\\*)($|\])/g, function (match, leadEscape, range, endEscape, close) {
  return leadEscape === ESCAPE
  ? "\\[".concat(range).concat(cleanRangeBackSlash(endEscape)).concat(close) : close === ']' ? endEscape.length % 2 === 0
  ? "[".concat(sanitizeRange(range)).concat(endEscape, "]") // Invalid range notaton
  : '[]' : '[]';
}],
[
/(?:[^*])$/,


function (match) {
  return /\/$/.test(match)
  ? "".concat(match, "$") // foo matches 'foo' and 'foo/'
  : "".concat(match, "(?=$|\\/$)");
}],
[/(\^|\\\/)?\\\*$/, function (_, p1) {
  var prefix = p1

  ? "".concat(p1, "[^/]+") // 'a*' matches 'a'
  : '[^/]*';
  return "".concat(prefix, "(?=$|\\/$)");
}]];

var regexCache = Object.create(null);

var makeRegex = function makeRegex(pattern, ignoreCase) {
  var source = regexCache[pattern];
  if (!source) {
    source = REPLACERS.reduce(function (prev, current) {
      return prev.replace(current[0], current[1].bind(pattern));
    }, pattern);
    regexCache[pattern] = source;
  }
  return ignoreCase ? new RegExp(source, 'i') : new RegExp(source);
};
var isString = function isString(subject) {
  return typeof subject === 'string';
};

var checkPattern = function checkPattern(pattern) {
  return pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)

  && pattern.indexOf('#') !== 0;
};
var splitPattern = function splitPattern(pattern) {
  return pattern.split(REGEX_SPLITALL_CRLF);
};
var IgnoreRule = /*#__PURE__*/_createClass(function IgnoreRule(origin, pattern, negative, regex) {
  _classCallCheck(this, IgnoreRule);
  this.origin = origin;
  this.pattern = pattern;
  this.negative = negative;
  this.regex = regex;
});
var createRule = function createRule(pattern, ignoreCase) {
  var origin = pattern;
  var negative = false;

  if (pattern.indexOf('!') === 0) {
    negative = true;
    pattern = pattern.substr(1);
  }
  pattern = pattern
  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');
  var regex = makeRegex(pattern, ignoreCase);
  return new IgnoreRule(origin, pattern, negative, regex);
};
var throwError = function throwError(message, Ctor) {
  throw new Ctor(message);
};
var checkPath = function checkPath(path, originalPath, doThrow) {
  if (!isString(path)) {
    return doThrow("path must be a string, but got `".concat(originalPath, "`"), TypeError);
  }

  if (!path) {
    return doThrow("path must not be empty", TypeError);
  }

  if (checkPath.isNotRelative(path)) {
    var r = '`path.relative()`d';
    return doThrow("path should be a ".concat(r, " string, but got \"").concat(originalPath, "\""), RangeError);
  }
  return true;
};
var isNotRelative = function isNotRelative(path) {
  return REGEX_TEST_INVALID_PATH.test(path);
};
checkPath.isNotRelative = isNotRelative;
checkPath.convert = function (p) {
  return p;
};
var Ignore = /*#__PURE__*/function () {
  function Ignore() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$ignorecase = _ref.ignorecase,
      ignorecase = _ref$ignorecase === void 0 ? true : _ref$ignorecase,
      _ref$ignoreCase = _ref.ignoreCase,
      ignoreCase = _ref$ignoreCase === void 0 ? ignorecase : _ref$ignoreCase,
      _ref$allowRelativePat = _ref.allowRelativePaths,
      allowRelativePaths = _ref$allowRelativePat === void 0 ? false : _ref$allowRelativePat;
    _classCallCheck(this, Ignore);
    define(this, KEY_IGNORE, true);
    this._rules = [];
    this._ignoreCase = ignoreCase;
    this._allowRelativePaths = allowRelativePaths;
    this._initCache();
  }
  _createClass(Ignore, [{
    key: "_initCache",
    value: function _initCache() {
      this._ignoreCache = Object.create(null);
      this._testCache = Object.create(null);
    }
  }, {
    key: "_addPattern",
    value: function _addPattern(pattern) {
      if (pattern && pattern[KEY_IGNORE]) {
        this._rules = this._rules.concat(pattern._rules);
        this._added = true;
        return;
      }
      if (checkPattern(pattern)) {
        var rule = createRule(pattern, this._ignoreCase);
        this._added = true;
        this._rules.push(rule);
      }
    }

  }, {
    key: "add",
    value: function add(pattern) {
      this._added = false;
      makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);

      if (this._added) {
        this._initCache();
      }
      return this;
    }

  }, {
    key: "addPattern",
    value: function addPattern(pattern) {
      return this.add(pattern);
    }




  }, {
    key: "_testOne",
    value: function _testOne(path, checkUnignored) {
      var ignored = false;
      var unignored = false;
      this._rules.forEach(function (rule) {
        var negative = rule.negative;
        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
          return;
        }
        var matched = rule.regex.test(path);
        if (matched) {
          ignored = !negative;
          unignored = negative;
        }
      });
      return {
        ignored: ignored,
        unignored: unignored
      };
    }

  }, {
    key: "_test",
    value: function _test(originalPath, cache, checkUnignored, slices) {
      var path = originalPath
      && checkPath.convert(originalPath);
      checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);
      return this._t(path, cache, checkUnignored, slices);
    }
  }, {
    key: "_t",
    value: function _t(path, cache, checkUnignored, slices) {
      if (path in cache) {
        return cache[path];
      }
      if (!slices) {
        slices = path.split(SLASH);
      }
      slices.pop();

      if (!slices.length) {
        return cache[path] = this._testOne(path, checkUnignored);
      }
      var parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);

      return cache[path] = parent.ignored
      ? parent : this._testOne(path, checkUnignored);
    }
  }, {
    key: "ignores",
    value: function ignores(path) {
      return this._test(path, this._ignoreCache, false).ignored;
    }
  }, {
    key: "createFilter",
    value: function createFilter() {
      var _this = this;
      return function (path) {
        return !_this.ignores(path);
      };
    }
  }, {
    key: "filter",
    value: function filter(paths) {
      return makeArray(paths).filter(this.createFilter());
    }

  }, {
    key: "test",
    value: function test(path) {
      return this._test(path, this._testCache, true);
    }
  }]);
  return Ignore;
}();
var factory = function factory(options) {
  return new Ignore(options);
};
var isPathValid = function isPathValid(path) {
  return checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
};
factory.isPathValid = isPathValid;

factory["default"] = factory;
module.exports = factory;

/* istanbul ignore if */
if (
typeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {
  /* eslint no-control-regex: "off" */
  var makePosix = function makePosix(str) {
    return /^\\\\\?\\/.test(str) || /[\0-\x1F"<>\|]+/.test(str) ? str : str.replace(/\\/g, '/');
  };
  checkPath.convert = makePosix;

  var REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
  checkPath.isNotRelative = function (path) {
    return REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
  };
}
