const path = require('path')
const semver = require('semver')

const defaultPolyfills = [
  'es.array.iterator',
  'es.promise',
  'es.object.assign',
  'es.promise.finally'
]

const {
  default: getTargets,
  isRequired
} = require('@babel/helper-compilation-targets')

function getIntersectionTargets (targets, constraintTargets) {
  const intersection = Object.keys(constraintTargets).reduce(
    (results, browser) => {
      if (!targets[browser]) {
        return results
      }

      results[browser] = semver.gt(
        semver.coerce(constraintTargets[browser]),
        semver.coerce(targets[browser])
      )
        ? constraintTargets[browser]
        : targets[browser]

      return results
    },
    {}
  )

  return intersection
}

function getModernTargets (targets) {
  const allModernTargets = getTargets(
    { esmodules: true },
    { ignoreBrowserslistConfig: true }
  )

  const result = getIntersectionTargets(targets, allModernTargets)

  result.samsung = '12.0.0'

  return result
}

function getWCTargets (targets) {
  const allWCTargets = getTargets(
    {
      browsers: [
        'Chrome >= 46',
        'Firefox >= 45',
        'Safari >= 10',
        'Edge >= 13',
        'iOS >= 10',
        'Electron >= 0.36'
      ]
    },
    { ignoreBrowserslistConfig: true }
  )

  return getIntersectionTargets(targets, allWCTargets)
}

function getPolyfills (targets, includes) {
  if (!targets || !Object.keys(targets).length) {
    return includes
  }

  const compatData = require('core-js-compat').data
  return includes.filter(item => {
    if (!compatData[item]) {
      throw new Error(`Cannot find polyfill ${item}, please refer to 'core-js-compat' for a complete list of available modules`)
    }

    return isRequired(item, targets, { compatData })
  })
}

module.exports = (context, options = {}) => {
  const presets = []
  const plugins = []
  const defaultEntryFiles = JSON.parse(process.env.VUE_CLI_ENTRY_FILES || '[]')

  if (!process.env.VUE_CLI_TEST && process.env.NODE_ENV === 'test') {
    process.env.VUE_CLI_BABEL_TARGET_NODE = 'true'
    process.env.VUE_CLI_BABEL_TRANSPILE_MODULES = 'true'
  }

  if (options.jsx !== false) {
    let jsxOptions = {}
    if (typeof options.jsx === 'object') {
      jsxOptions = options.jsx
    }

    let vueVersion = 2
    try {
      const Vue = require('vue')
      vueVersion = semver.major(Vue.version)
    } catch (e) {}

    if (vueVersion === 2) {
      presets.push([require('@vue/babel-preset-jsx'), jsxOptions])
    } else if (vueVersion === 3) {
      plugins.push([require('@vue/babel-plugin-jsx'), jsxOptions])
    }
  }

  const runtimePath = path.dirname(require.resolve('@babel/runtime/package.json'))
  const runtimeVersion = require('@babel/runtime/package.json').version
  const {
    polyfills: userPolyfills,
    loose = false,
    debug = false,
    useBuiltIns = 'usage',
    modules = false,
    bugfixes = true,
    targets: rawTargets,
    spec,
    ignoreBrowserslistConfig,
    configPath,
    include,
    exclude,
    shippedProposals,
    forceAllTransforms,
    decoratorsBeforeExport,
    decoratorsLegacy,
    entryFiles = defaultEntryFiles,

    absoluteRuntime = runtimePath,

    version = runtimeVersion
  } = options

  let targets = getTargets(rawTargets, { ignoreBrowserslistConfig, configPath })

  if (!targets.chrome || semver.gt(targets.chrome, '79.0.0')) {
    targets.chrome = '79.0.0'
  }

  if (process.env.VUE_CLI_BABEL_TARGET_NODE) {
    targets = { node: '12' }
  } else if (process.env.VUE_CLI_BUILD_TARGET === 'wc' || process.env.VUE_CLI_BUILD_TARGET === 'wc-async') {
    targets = getWCTargets(targets)
  } else if (process.env.VUE_CLI_MODERN_BUILD) {
    targets = getModernTargets(targets)
  }

  let polyfills
  const buildTarget = process.env.VUE_CLI_BUILD_TARGET || 'app'
  if (
    buildTarget === 'app' &&
    useBuiltIns === 'usage' &&
    !process.env.VUE_CLI_BABEL_TARGET_NODE
  ) {
    polyfills = getPolyfills(targets, userPolyfills || defaultPolyfills)
    plugins.push([
      require('./polyfillsPlugin'),
      { polyfills, entryFiles, useAbsolutePath: !!absoluteRuntime }
    ])
  } else {
    polyfills = []
  }

  const envOptions = {
    bugfixes,
    corejs: useBuiltIns ? require('core-js/package.json').version : false,
    spec,
    loose,
    debug,
    modules,
    targets,
    useBuiltIns,
    ignoreBrowserslistConfig,
    configPath,
    include,
    exclude: polyfills.concat(exclude || []),
    shippedProposals,
    forceAllTransforms
  }

  if (process.env.VUE_CLI_BABEL_TRANSPILE_MODULES) {
    envOptions.modules = 'commonjs'
    if (process.env.VUE_CLI_BABEL_TARGET_NODE) {
      plugins.push(require('babel-plugin-dynamic-import-node'))
    }
  }

  presets.unshift([require('@babel/preset-env'), envOptions])

  plugins.push(
    require('@babel/plugin-syntax-dynamic-import'),
    [require('@babel/plugin-proposal-decorators'), {
      decoratorsBeforeExport,
      legacy: decoratorsLegacy !== false
    }],
    [require('@babel/plugin-proposal-class-properties'), { loose }]
  )

  plugins.push([require('@babel/plugin-transform-runtime'), {
    regenerator: useBuiltIns !== 'usage',

    corejs: false,

    helpers: useBuiltIns === 'usage',
    useESModules: !process.env.VUE_CLI_BABEL_TRANSPILE_MODULES,

    absoluteRuntime,

    version
  }])

  return {
    sourceType: 'unambiguous',
    overrides: [{
      exclude: [/@babel[\/|\\\\]runtime/, /core-js/],
      presets,
      plugins
    }, {
      include: [/@babel[\/|\\\\]runtime/],
      presets: [
        [require('@babel/preset-env'), envOptions]
      ]
    }]
  }
}

process.env.VUE_CLI_TRANSPILE_BABEL_RUNTIME = true
