
const acorn = require('acorn')
const walk = require('acorn-walk')
const mapValues = require('lodash.mapvalues')
const transform = require('lodash.transform')
const zlib = require('zlib')
const { warn } = require('@vue/cli-shared-utils')

exports.analyzeBundle = function analyzeBundle (bundleStats, assetSources) {
  const jsAssets = []
  const otherAssets = []

  bundleStats.assets.forEach(asset => {
    if (asset.name.endsWith('.js') && asset.chunks && asset.chunks.length) {
      jsAssets.push(asset)
    } else {
      otherAssets.push(asset)
    }
  })

  let bundlesSources = null
  let parsedModules = null

  bundlesSources = {}
  parsedModules = {}

  for (const asset of jsAssets) {
    const source = assetSources.get(asset.name)
    let bundleInfo

    try {
      bundleInfo = parseBundle(source)
    } catch (err) {
      bundleInfo = null
    }

    if (!bundleInfo) {
      warn(
        `\nCouldn't parse bundle asset "${asset.fullPath}".\n` +
        'Analyzer will use module sizes from stats file.\n'
      )
      parsedModules = null
      bundlesSources = null
      break
    }

    bundlesSources[asset.name] = bundleInfo.src
    Object.assign(parsedModules, bundleInfo.modules)
  }


  bundleStats.modules.forEach(module => {
    const parsedSrc = parsedModules && parsedModules[module.id]
    module.size = {
      stats: module.size
    }
    if (parsedSrc) {
      module.size.parsed = parsedSrc.length
      module.size.gzip = getGzipSize(parsedSrc)
    } else {
      module.size.parsed = module.size.stats
      module.size.gzip = 0
    }
  })

  jsAssets.forEach(asset => {
    const src = bundlesSources && bundlesSources[asset.name]
    asset.size = {
      stats: asset.size
    }
    if (src) {
      asset.size.parsed = src.length
      asset.size.gzip = getGzipSize(src)
    } else {
      asset.size.parsed = asset.size.stats
      asset.size.gzip = 0
    }
  }, {})

  otherAssets.forEach(asset => {
    const src = assetSources.get(asset.name)
    asset.size = {
      stats: asset.size,
      parsed: asset.size
    }
    if (src) {
      asset.size.gzip = getGzipSize(src)
    } else {
      asset.size.gzip = 0
    }
  })
}

function parseBundle (bundleContent) {
  const ast = acorn.parse(bundleContent, {
    sourceType: 'script',
    ecmaVersion: 2050
  })

  const walkState = {
    locations: null
  }

  walk.recursive(
    ast,
    walkState,
    {
      CallExpression (node, state, c) {
        if (state.sizes) return

        const args = node.arguments

        if (
          node.callee.type === 'Identifier' &&
          args.length >= 2 &&
          isArgumentContainsChunkIds(args[0]) &&
          isArgumentContainsModulesList(args[1])
        ) {
          state.locations = getModulesLocationFromFunctionArgument(args[1])
          return
        }

        if (
          node.callee.type === 'Identifier' &&
          (args.length === 2 || args.length === 3) &&
          isArgumentContainsChunkIds(args[0]) &&
          isArgumentArrayConcatContainingChunks(args[1])
        ) {
          state.locations = getModulesLocationFromArrayConcat(args[1])
          return
        }

        if (
          node.callee.type === 'FunctionExpression' &&
          !node.callee.id &&
          args.length === 1 &&
          isArgumentContainsModulesList(args[0])
        ) {
          state.locations = getModulesLocationFromFunctionArgument(args[0])
          return
        }

        if (
          isWindowPropertyPushExpression(node) &&
          args.length === 1 &&
          isArgumentContainingChunkIdsAndModulesList(args[0])
        ) {
          state.locations = getModulesLocationFromFunctionArgument(args[0].elements[1])
          return
        }

        args.forEach(arg => c(arg, state))
      }
    }
  )

  if (!walkState.locations) {
    return null
  }

  return {
    src: bundleContent,
    modules: mapValues(walkState.locations,
      loc => bundleContent.slice(loc.start, loc.end)
    )
  }
}

function getGzipSize (buffer) {
  return zlib.gzipSync(buffer).length
}

function isArgumentContainsChunkIds (arg) {
  return (arg.type === 'ArrayExpression' && arg.elements.every(isModuleId))
}

function isArgumentContainsModulesList (arg) {
  if (arg.type === 'ObjectExpression') {
    return arg.properties
      .map(prop => prop.value)
      .every(isModuleWrapper)
  }

  if (arg.type === 'ArrayExpression') {
    return arg.elements.every(elem =>
      !elem ||
      isModuleWrapper(elem)
    )
  }

  return false
}

function isArgumentContainingChunkIdsAndModulesList (arg) {
  if (
    arg.type === 'ArrayExpression' &&
    arg.elements.length >= 2 &&
    isArgumentContainsChunkIds(arg.elements[0]) &&
    isArgumentContainsModulesList(arg.elements[1])
  ) {
    return true
  }
  return false
}

function isArgumentArrayConcatContainingChunks (arg) {
  if (
    arg.type === 'CallExpression' &&
    arg.callee.type === 'MemberExpression' &&
    arg.callee.object.type === 'CallExpression' &&
    arg.callee.object.callee.type === 'Identifier' &&
    arg.callee.object.callee.name === 'Array' &&
    arg.callee.object.arguments.length === 1 &&
    isNumericId(arg.callee.object.arguments[0]) &&
    arg.callee.property.type === 'Identifier' &&
    arg.callee.property.name === 'concat' &&
    arg.arguments.length === 1 &&
    arg.arguments[0].type === 'ArrayExpression'
  ) {
    return true
  }

  return false
}

function isWindowPropertyPushExpression (node) {
  return node.callee.type === 'MemberExpression' &&
    node.callee.property.name === 'push' &&
    node.callee.object.type === 'AssignmentExpression' &&
    node.callee.object.left.object.name === 'window'
}

function isModuleWrapper (node) {
  return (
    ((node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') && !node.id) ||
    isModuleId(node) ||
    (node.type === 'ArrayExpression' && node.elements.length > 1 && isModuleId(node.elements[0]))
  )
}

function isModuleId (node) {
  return (node.type === 'Literal' && (isNumericId(node) || typeof node.value === 'string'))
}

function isNumericId (node) {
  return (node.type === 'Literal' && Number.isInteger(node.value) && node.value >= 0)
}

function getModulesLocationFromFunctionArgument (arg) {
  if (arg.type === 'ObjectExpression') {
    const modulesNodes = arg.properties

    return transform(modulesNodes, (result, moduleNode) => {
      const moduleId = moduleNode.key.name || moduleNode.key.value

      result[moduleId] = getModuleLocation(moduleNode.value)
    }, {})
  }

  if (arg.type === 'ArrayExpression') {
    const modulesNodes = arg.elements

    return transform(modulesNodes, (result, moduleNode, i) => {
      if (!moduleNode) return

      result[i] = getModuleLocation(moduleNode)
    }, {})
  }

  return {}
}

function getModulesLocationFromArrayConcat (arg) {
  const minId = arg.callee.object.arguments[0].value
  const modulesNodes = arg.arguments[0].elements

  return transform(modulesNodes, (result, moduleNode, i) => {
    if (!moduleNode) return

    result[i + minId] = getModuleLocation(moduleNode)
  }, {})
}

function getModuleLocation (node) {
  return { start: node.start, end: node.end }
}
