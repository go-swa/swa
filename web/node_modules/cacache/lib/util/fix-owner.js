'use strict'

const BB = require('bluebird')

const chownr = BB.promisify(require('chownr'))
const mkdirp = BB.promisify(require('mkdirp'))
const inflight = require('promise-inflight')
const inferOwner = require('infer-owner')

const self = { uid: null, gid: null }
const getSelf = () => {
  if (typeof self.uid !== 'number') {
    self.uid = process.getuid()
    const setuid = process.setuid
    process.setuid = (uid) => {
      self.uid = null
      process.setuid = setuid
      return process.setuid(uid)
    }
  }
  if (typeof self.gid !== 'number') {
    self.gid = process.getgid()
    const setgid = process.setgid
    process.setgid = (gid) => {
      self.gid = null
      process.setgid = setgid
      return process.setgid(gid)
    }
  }
}

module.exports.chownr = fixOwner
function fixOwner (cache, filepath) {
  if (!process.getuid) {
    return BB.resolve()
  }

  getSelf()
  if (self.uid !== 0) {
    return BB.resolve()
  }

  return BB.resolve(inferOwner(cache)).then(owner => {
    const { uid, gid } = owner

    if (self.uid === uid && self.gid === gid) {
      return
    }

    return inflight(
      'fixOwner: fixing ownership on ' + filepath,
      () => chownr(
        filepath,
        typeof uid === 'number' ? uid : self.uid,
        typeof gid === 'number' ? gid : self.gid
      ).catch({ code: 'ENOENT' }, () => null)
    )
  })
}

module.exports.chownr.sync = fixOwnerSync
function fixOwnerSync (cache, filepath) {
  if (!process.getuid) {
    return
  }
  const { uid, gid } = inferOwner.sync(cache)
  getSelf()
  if (self.uid === uid && self.gid === gid) {
    return
  }
  try {
    chownr.sync(
      filepath,
      typeof uid === 'number' ? uid : self.uid,
      typeof gid === 'number' ? gid : self.gid
    )
  } catch (err) {
    if (err.code === 'ENOENT') {
      return null
    }
    throw err
  }
}

module.exports.mkdirfix = mkdirfix
function mkdirfix (cache, p, cb) {
  return BB.resolve(inferOwner(cache)).then(() => {
    return mkdirp(p).then(made => {
      if (made) {
        return fixOwner(cache, made).then(() => made)
      }
    }).catch({ code: 'EEXIST' }, () => {
      return fixOwner(cache, p).then(() => null)
    })
  })
}

module.exports.mkdirfix.sync = mkdirfixSync
function mkdirfixSync (cache, p) {
  try {
    inferOwner.sync(cache)
    const made = mkdirp.sync(p)
    if (made) {
      fixOwnerSync(cache, made)
      return made
    }
  } catch (err) {
    if (err.code === 'EEXIST') {
      fixOwnerSync(cache, p)
      return null
    } else {
      throw err
    }
  }
}
