function make_array (subject) {
  return Array.isArray(subject)
    ? subject
    : [subject]
}

const REGEX_BLANK_LINE = /^\s+$/
const REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\!/
const REGEX_LEADING_EXCAPED_HASH = /^\\#/
const SLASH = '/'
const KEY_IGNORE = typeof Symbol !== 'undefined'
  ? Symbol.for('node-ignore')
  /* istanbul ignore next */
  : 'node-ignore'

const define = (object, key, value) =>
  Object.defineProperty(object, key, {value})

const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g

const sanitizeRange = range => range.replace(
  REGEX_REGEXP_RANGE,
  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)
    ? match
    : ''
)


const DEFAULT_REPLACER_PREFIX = [

  [
    /\\?\s+$/,
    match => match.indexOf('\\') === 0
      ? ' '
      : ''
  ],

  [
    /\\\s/g,
    () => ' '
  ],


  [
    /[\\^$.|*+(){]/g,
    match => `\\${match}`
  ],

  [
    /\[([^\]/]*)($|\])/g,
    (match, p1, p2) => p2 === ']'
      ? `[${sanitizeRange(p1)}]`
      : `\\${match}`
  ],

  [
    /(?!\\)\?/g,
    () => '[^/]'
  ],

  [

    /^\//,
    () => '^'
  ],

  [
    /\//g,
    () => '\\/'
  ],

  [
    /^\^*\\\*\\\*\\\//,

    () => '^(?:.*\\/)?'
  ]
]

const DEFAULT_REPLACER_SUFFIX = [
  [
    /^(?=[^^])/,
    function startingReplacer () {
      return !/\/(?!$)/.test(this)
        ? '(?:^|\\/)'

        : '^'
    }
  ],

  [
    /\\\/\\\*\\\*(?=\\\/|$)/g,


    (match, index, str) => index + 6 < str.length

      ? '(?:\\/[^\\/]+)*'


      : '\\/.+'
  ],

  [

    /(^|[^\\]+)\\\*(?=.+)/g,

    (match, p1) => `${p1}[^\\/]*`
  ],

  [
    /(\^|\\\/)?\\\*$/,
    (match, p1) => {
      const prefix = p1

        ? `${p1}[^/]+`

        : '[^/]*'

      return `${prefix}(?=$|\\/$)`
    }
  ],

  [
    /\\\\\\/g,
    () => '\\'
  ]
]

const POSITIVE_REPLACERS = [
  ...DEFAULT_REPLACER_PREFIX,


  [
    /(?:[^*/])$/,

    match => `${match}(?=$|\\/)`
  ],

  ...DEFAULT_REPLACER_SUFFIX
]

const NEGATIVE_REPLACERS = [
  ...DEFAULT_REPLACER_PREFIX,


  [
    /(?:[^*])$/,
    match => `${match}(?=$|\\/$)`
  ],

  ...DEFAULT_REPLACER_SUFFIX
]

const cache = Object.create(null)

const make_regex = (pattern, negative, ignorecase) => {
  const r = cache[pattern]
  if (r) {
    return r
  }

  const replacers = negative
    ? NEGATIVE_REPLACERS
    : POSITIVE_REPLACERS

  const source = replacers.reduce(
    (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
    pattern
  )

  return cache[pattern] = ignorecase
    ? new RegExp(source, 'i')
    : new RegExp(source)
}

const checkPattern = pattern => pattern
  && typeof pattern === 'string'
  && !REGEX_BLANK_LINE.test(pattern)

  && pattern.indexOf('#') !== 0

const createRule = (pattern, ignorecase) => {
  const origin = pattern
  let negative = false

  if (pattern.indexOf('!') === 0) {
    negative = true
    pattern = pattern.substr(1)
  }

  pattern = pattern
  .replace(REGEX_LEADING_EXCAPED_EXCLAMATION, '!')
  .replace(REGEX_LEADING_EXCAPED_HASH, '#')

  const regex = make_regex(pattern, negative, ignorecase)

  return {
    origin,
    pattern,
    negative,
    regex
  }
}

class IgnoreBase {
  constructor ({
    ignorecase = true
  } = {}) {
    this._rules = []
    this._ignorecase = ignorecase
    define(this, KEY_IGNORE, true)
    this._initCache()
  }

  _initCache () {
    this._cache = Object.create(null)
  }

  add (pattern) {
    this._added = false

    if (typeof pattern === 'string') {
      pattern = pattern.split(/\r?\n/g)
    }

    make_array(pattern).forEach(this._addPattern, this)

    if (this._added) {
      this._initCache()
    }

    return this
  }

  addPattern (pattern) {
    return this.add(pattern)
  }

  _addPattern (pattern) {
    if (pattern && pattern[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules)
      this._added = true
      return
    }

    if (checkPattern(pattern)) {
      const rule = createRule(pattern, this._ignorecase)
      this._added = true
      this._rules.push(rule)
    }
  }

  filter (paths) {
    return make_array(paths).filter(path => this._filter(path))
  }

  createFilter () {
    return path => this._filter(path)
  }

  ignores (path) {
    return !this._filter(path)
  }

  _filter (path, slices) {
    if (!path) {
      return false
    }

    if (path in this._cache) {
      return this._cache[path]
    }

    if (!slices) {
      slices = path.split(SLASH)
    }

    slices.pop()

    return this._cache[path] = slices.length
      ? this._filter(slices.join(SLASH) + SLASH, slices)
        && this._test(path)

      : this._test(path)
  }

  _test (path) {
    let matched = 0

    this._rules.forEach(rule => {
      if (!(matched ^ rule.negative)) {
        matched = rule.negative ^ rule.regex.test(path)
      }
    })

    return !matched
  }
}

/* istanbul ignore if  */
if (
  typeof process !== 'undefined'
  && (
    process.env && process.env.IGNORE_TEST_WIN32
    || process.platform === 'win32'
  )
) {
  const filter = IgnoreBase.prototype._filter

  /* eslint no-control-regex: "off" */
  const make_posix = str => /^\\\\\?\\/.test(str)
  || /[^\x00-\x80]+/.test(str)
    ? str
    : str.replace(/\\/g, '/')

  IgnoreBase.prototype._filter = function filterWin32 (path, slices) {
    path = make_posix(path)
    return filter.call(this, path, slices)
  }
}

module.exports = options => new IgnoreBase(options)
