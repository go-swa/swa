'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function make_array(subject) {
  return Array.isArray(subject) ? subject : [subject];
}

var REGEX_BLANK_LINE = /^\s+$/;
var REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
var REGEX_LEADING_EXCAPED_HASH = /^\\#/;
var SLASH = '/';
var KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol.for('node-ignore')
/* istanbul ignore next */
: 'node-ignore';

var define = function define(object, key, value) {
  return Object.defineProperty(object, key, { value });
};

var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;

var sanitizeRange = function sanitizeRange(range) {
  return range.replace(REGEX_REGEXP_RANGE, function (match, from, to) {
    return from.charCodeAt(0) <= to.charCodeAt(0) ? match
    : '';
  });
};


var DEFAULT_REPLACER_PREFIX = [

[
/\\?\s+$/, function (match) {
  return match.indexOf('\\') === 0 ? ' ' : '';
}],

[/\\\s/g, function () {
  return ' ';
}],


[/[\\^$.|*+(){]/g, function (match) {
  return `\\${match}`;
}], [
/\[([^\]/]*)($|\])/g, function (match, p1, p2) {
  return p2 === ']' ? `[${sanitizeRange(p1)}]` : `\\${match}`;
}], [
/(?!\\)\?/g, function () {
  return '[^/]';
}],

[

/^\//, function () {
  return '^';
}],

[/\//g, function () {
  return '\\/';
}], [
/^\^*\\\*\\\*\\\//,

function () {
  return '^(?:.*\\/)?';
}]];

var DEFAULT_REPLACER_SUFFIX = [
[
/^(?=[^^])/, function startingReplacer() {
  return !/\/(?!$)/.test(this)
  ? '(?:^|\\/)'

  : '^';
}],

[
/\\\/\\\*\\\*(?=\\\/|$)/g,


function (match, index, str) {
  return index + 6 < str.length

  ? '(?:\\/[^\\/]+)*'


  : '\\/.+';
}],

[

/(^|[^\\]+)\\\*(?=.+)/g,

function (match, p1) {
  return `${p1}[^\\/]*`;
}],

[/(\^|\\\/)?\\\*$/, function (match, p1) {
  var prefix = p1

  ? `${p1}[^/]+`

  : '[^/]*';

  return `${prefix}(?=$|\\/$)`;
}], [
/\\\\\\/g, function () {
  return '\\';
}]];

var POSITIVE_REPLACERS = [].concat(DEFAULT_REPLACER_PREFIX, [


[
/(?:[^*/])$/,

function (match) {
  return `${match}(?=$|\\/)`;
}]], DEFAULT_REPLACER_SUFFIX);

var NEGATIVE_REPLACERS = [].concat(DEFAULT_REPLACER_PREFIX, [


[/(?:[^*])$/, function (match) {
  return `${match}(?=$|\\/$)`;
}]], DEFAULT_REPLACER_SUFFIX);

var cache = Object.create(null);

var make_regex = function make_regex(pattern, negative, ignorecase) {
  var r = cache[pattern];
  if (r) {
    return r;
  }

  var replacers = negative ? NEGATIVE_REPLACERS : POSITIVE_REPLACERS;

  var source = replacers.reduce(function (prev, current) {
    return prev.replace(current[0], current[1].bind(pattern));
  }, pattern);

  return cache[pattern] = ignorecase ? new RegExp(source, 'i') : new RegExp(source);
};

var checkPattern = function checkPattern(pattern) {
  return pattern && typeof pattern === 'string' && !REGEX_BLANK_LINE.test(pattern)

  && pattern.indexOf('#') !== 0;
};

var createRule = function createRule(pattern, ignorecase) {
  var origin = pattern;
  var negative = false;

  if (pattern.indexOf('!') === 0) {
    negative = true;
    pattern = pattern.substr(1);
  }

  pattern = pattern
  .replace(REGEX_LEADING_EXCAPED_EXCLAMATION, '!')
  .replace(REGEX_LEADING_EXCAPED_HASH, '#');

  var regex = make_regex(pattern, negative, ignorecase);

  return {
    origin,
    pattern,
    negative,
    regex
  };
};

var IgnoreBase = function () {
  function IgnoreBase() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$ignorecase = _ref.ignorecase,
        ignorecase = _ref$ignorecase === undefined ? true : _ref$ignorecase;

    _classCallCheck(this, IgnoreBase);

    this._rules = [];
    this._ignorecase = ignorecase;
    define(this, KEY_IGNORE, true);
    this._initCache();
  }

  _createClass(IgnoreBase, [{
    key: '_initCache',
    value: function _initCache() {
      this._cache = Object.create(null);
    }


  }, {
    key: 'add',
    value: function add(pattern) {
      this._added = false;

      if (typeof pattern === 'string') {
        pattern = pattern.split(/\r?\n/g);
      }

      make_array(pattern).forEach(this._addPattern, this);

      if (this._added) {
        this._initCache();
      }

      return this;
    }


  }, {
    key: 'addPattern',
    value: function addPattern(pattern) {
      return this.add(pattern);
    }
  }, {
    key: '_addPattern',
    value: function _addPattern(pattern) {
      if (pattern && pattern[KEY_IGNORE]) {
        this._rules = this._rules.concat(pattern._rules);
        this._added = true;
        return;
      }

      if (checkPattern(pattern)) {
        var rule = createRule(pattern, this._ignorecase);
        this._added = true;
        this._rules.push(rule);
      }
    }
  }, {
    key: 'filter',
    value: function filter(paths) {
      var _this = this;

      return make_array(paths).filter(function (path) {
        return _this._filter(path);
      });
    }
  }, {
    key: 'createFilter',
    value: function createFilter() {
      var _this2 = this;

      return function (path) {
        return _this2._filter(path);
      };
    }
  }, {
    key: 'ignores',
    value: function ignores(path) {
      return !this._filter(path);
    }


  }, {
    key: '_filter',
    value: function _filter(path, slices) {
      if (!path) {
        return false;
      }

      if (path in this._cache) {
        return this._cache[path];
      }

      if (!slices) {
        slices = path.split(SLASH);
      }

      slices.pop();

      return this._cache[path] = slices.length
      ? this._filter(slices.join(SLASH) + SLASH, slices) && this._test(path)

      : this._test(path);
    }


  }, {
    key: '_test',
    value: function _test(path) {
      var matched = 0;

      this._rules.forEach(function (rule) {
        if (!(matched ^ rule.negative)) {
          matched = rule.negative ^ rule.regex.test(path);
        }
      });

      return !matched;
    }
  }]);

  return IgnoreBase;
}();

/* istanbul ignore if  */


if (
typeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {
  var filter = IgnoreBase.prototype._filter;

  /* eslint no-control-regex: "off" */
  var make_posix = function make_posix(str) {
    return (/^\\\\\?\\/.test(str) || /[^\x00-\x80]+/.test(str) ? str : str.replace(/\\/g, '/')
    );
  };

  IgnoreBase.prototype._filter = function filterWin32(path, slices) {
    path = make_posix(path);
    return filter.call(this, path, slices);
  };
}

module.exports = function (options) {
  return new IgnoreBase(options);
};
