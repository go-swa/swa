"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _assert = _interopRequireDefault(require("assert"));
var leap = _interopRequireWildcard(require("./leap"));
var meta = _interopRequireWildcard(require("./meta"));
var util = _interopRequireWildcard(require("./util"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasOwn = Object.prototype.hasOwnProperty;
function Emitter(contextId) {
  _assert["default"].ok(this instanceof Emitter);
  util.getTypes().assertIdentifier(contextId);

  this.nextTempId = 0;

  this.contextId = contextId;

  this.listing = [];

  this.marked = [true];
  this.insertedLocs = new Set();

  this.finalLoc = this.loc();

  this.tryEntries = [];

  this.leapManager = new leap.LeapManager(this);
}
var Ep = Emitter.prototype;
exports.Emitter = Emitter;

Ep.loc = function () {
  var l = util.getTypes().numericLiteral(-1);
  this.insertedLocs.add(l);
  return l;
};
Ep.getInsertedLocs = function () {
  return this.insertedLocs;
};
Ep.getContextId = function () {
  return util.getTypes().clone(this.contextId);
};

Ep.mark = function (loc) {
  util.getTypes().assertLiteral(loc);
  var index = this.listing.length;
  if (loc.value === -1) {
    loc.value = index;
  } else {
    _assert["default"].strictEqual(loc.value, index);
  }
  this.marked[index] = true;
  return loc;
};
Ep.emit = function (node) {
  var t = util.getTypes();
  if (t.isExpression(node)) {
    node = t.expressionStatement(node);
  }
  t.assertStatement(node);
  this.listing.push(node);
};

Ep.emitAssign = function (lhs, rhs) {
  this.emit(this.assign(lhs, rhs));
  return lhs;
};

Ep.assign = function (lhs, rhs) {
  var t = util.getTypes();
  return t.expressionStatement(t.assignmentExpression("=", t.cloneDeep(lhs), rhs));
};

Ep.contextProperty = function (name, computed) {
  var t = util.getTypes();
  return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);
};

Ep.stop = function (rval) {
  if (rval) {
    this.setReturnValue(rval);
  }
  this.jump(this.finalLoc);
};
Ep.setReturnValue = function (valuePath) {
  util.getTypes().assertExpression(valuePath.value);
  this.emitAssign(this.contextProperty("rval"), this.explodeExpression(valuePath));
};
Ep.clearPendingException = function (tryLoc, assignee) {
  var t = util.getTypes();
  t.assertLiteral(tryLoc);
  var catchCall = t.callExpression(this.contextProperty("catch", true), [t.clone(tryLoc)]);
  if (assignee) {
    this.emitAssign(assignee, catchCall);
  } else {
    this.emit(catchCall);
  }
};

Ep.jump = function (toLoc) {
  this.emitAssign(this.contextProperty("next"), toLoc);
  this.emit(util.getTypes().breakStatement());
};

Ep.jumpIf = function (test, toLoc) {
  var t = util.getTypes();
  t.assertExpression(test);
  t.assertLiteral(toLoc);
  this.emit(t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()])));
};

Ep.jumpIfNot = function (test, toLoc) {
  var t = util.getTypes();
  t.assertExpression(test);
  t.assertLiteral(toLoc);
  var negatedTest;
  if (t.isUnaryExpression(test) && test.operator === "!") {
    negatedTest = test.argument;
  } else {
    negatedTest = t.unaryExpression("!", test);
  }
  this.emit(t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()])));
};

Ep.makeTempVar = function () {
  return this.contextProperty("t" + this.nextTempId++);
};
Ep.getContextFunction = function (id) {
  var t = util.getTypes();
  return t.functionExpression(id || null /*Anonymous*/, [this.getContextId()], t.blockStatement([this.getDispatchLoop()]), false,
  false // Nor an expression.
  );
};

Ep.getDispatchLoop = function () {
  var self = this;
  var t = util.getTypes();
  var cases = [];
  var current;

  var alreadyEnded = false;
  self.listing.forEach(function (stmt, i) {
    if (self.marked.hasOwnProperty(i)) {
      cases.push(t.switchCase(t.numericLiteral(i), current = []));
      alreadyEnded = false;
    }
    if (!alreadyEnded) {
      current.push(stmt);
      if (t.isCompletionStatement(stmt)) alreadyEnded = true;
    }
  });

  this.finalLoc.value = this.listing.length;
  cases.push(t.switchCase(this.finalLoc, [
  ]),
  t.switchCase(t.stringLiteral("end"), [
  t.returnStatement(t.callExpression(this.contextProperty("stop"), []))]));
  return t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression("=", this.contextProperty("prev"), this.contextProperty("next")), cases));
};
Ep.getTryLocsList = function () {
  if (this.tryEntries.length === 0) {
    return null;
  }
  var t = util.getTypes();
  var lastLocValue = 0;
  return t.arrayExpression(this.tryEntries.map(function (tryEntry) {
    var thisLocValue = tryEntry.firstLoc.value;
    _assert["default"].ok(thisLocValue >= lastLocValue, "try entries out of order");
    lastLocValue = thisLocValue;
    var ce = tryEntry.catchEntry;
    var fe = tryEntry.finallyEntry;
    var locs = [tryEntry.firstLoc,
    ce ? ce.firstLoc : null];
    if (fe) {
      locs[2] = fe.firstLoc;
      locs[3] = fe.afterLoc;
    }
    return t.arrayExpression(locs.map(function (loc) {
      return loc && t.clone(loc);
    }));
  }));
};




Ep.explode = function (path, ignoreResult) {
  var t = util.getTypes();
  var node = path.node;
  var self = this;
  t.assertNode(node);
  if (t.isDeclaration(node)) throw getDeclError(node);
  if (t.isStatement(node)) return self.explodeStatement(path);
  if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);
  switch (node.type) {
    case "Program":
      return path.get("body").map(self.explodeStatement, self);
    case "VariableDeclarator":
      throw getDeclError(node);

    case "Property":
    case "SwitchCase":
    case "CatchClause":
      throw new Error(node.type + " nodes should be handled by their parents");
    default:
      throw new Error("unknown Node of type " + JSON.stringify(node.type));
  }
};
function getDeclError(node) {
  return new Error("all declarations should have been transformed into " + "assignments before the Exploder began its work: " + JSON.stringify(node));
}
Ep.explodeStatement = function (path, labelId) {
  var t = util.getTypes();
  var stmt = path.node;
  var self = this;
  var before, after, head;
  t.assertStatement(stmt);
  if (labelId) {
    t.assertIdentifier(labelId);
  } else {
    labelId = null;
  }

  if (t.isBlockStatement(stmt)) {
    path.get("body").forEach(function (path) {
      self.explodeStatement(path);
    });
    return;
  }
  if (!meta.containsLeap(stmt)) {
    self.emit(stmt);
    return;
  }
  switch (stmt.type) {
    case "ExpressionStatement":
      self.explodeExpression(path.get("expression"), true);
      break;
    case "LabeledStatement":
      after = this.loc();

      self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), function () {
        self.explodeStatement(path.get("body"), stmt.label);
      });
      self.mark(after);
      break;
    case "WhileStatement":
      before = this.loc();
      after = this.loc();
      self.mark(before);
      self.jumpIfNot(self.explodeExpression(path.get("test")), after);
      self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {
        self.explodeStatement(path.get("body"));
      });
      self.jump(before);
      self.mark(after);
      break;
    case "DoWhileStatement":
      var first = this.loc();
      var test = this.loc();
      after = this.loc();
      self.mark(first);
      self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {
        self.explode(path.get("body"));
      });
      self.mark(test);
      self.jumpIf(self.explodeExpression(path.get("test")), first);
      self.mark(after);
      break;
    case "ForStatement":
      head = this.loc();
      var update = this.loc();
      after = this.loc();
      if (stmt.init) {
        self.explode(path.get("init"), true);
      }
      self.mark(head);
      if (stmt.test) {
        self.jumpIfNot(self.explodeExpression(path.get("test")), after);
      } else {
      }
      self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {
        self.explodeStatement(path.get("body"));
      });
      self.mark(update);
      if (stmt.update) {
        self.explode(path.get("update"), true);
      }
      self.jump(head);
      self.mark(after);
      break;
    case "TypeCastExpression":
      return self.explodeExpression(path.get("expression"));
    case "ForInStatement":
      head = this.loc();
      after = this.loc();
      var keyIterNextFn = self.makeTempVar();
      self.emitAssign(keyIterNextFn, t.callExpression(util.runtimeProperty("keys"), [self.explodeExpression(path.get("right"))]));
      self.mark(head);
      var keyInfoTmpVar = self.makeTempVar();
      self.jumpIf(t.memberExpression(t.assignmentExpression("=", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier("done"), false), after);
      self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier("value"), false));
      self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {
        self.explodeStatement(path.get("body"));
      });
      self.jump(head);
      self.mark(after);
      break;
    case "BreakStatement":
      self.emitAbruptCompletion({
        type: "break",
        target: self.leapManager.getBreakLoc(stmt.label)
      });
      break;
    case "ContinueStatement":
      self.emitAbruptCompletion({
        type: "continue",
        target: self.leapManager.getContinueLoc(stmt.label)
      });
      break;
    case "SwitchStatement":
      var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get("discriminant")));
      after = this.loc();
      var defaultLoc = this.loc();
      var condition = defaultLoc;
      var caseLocs = [];

      var cases = stmt.cases || [];
      for (var i = cases.length - 1; i >= 0; --i) {
        var c = cases[i];
        t.assertSwitchCase(c);
        if (c.test) {
          condition = t.conditionalExpression(t.binaryExpression("===", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition);
        } else {
          caseLocs[i] = defaultLoc;
        }
      }
      var discriminant = path.get("discriminant");
      util.replaceWithOrRemove(discriminant, condition);
      self.jump(self.explodeExpression(discriminant));
      self.leapManager.withEntry(new leap.SwitchEntry(after), function () {
        path.get("cases").forEach(function (casePath) {
          var i = casePath.key;
          self.mark(caseLocs[i]);
          casePath.get("consequent").forEach(function (path) {
            self.explodeStatement(path);
          });
        });
      });
      self.mark(after);
      if (defaultLoc.value === -1) {
        self.mark(defaultLoc);
        _assert["default"].strictEqual(after.value, defaultLoc.value);
      }
      break;
    case "IfStatement":
      var elseLoc = stmt.alternate && this.loc();
      after = this.loc();
      self.jumpIfNot(self.explodeExpression(path.get("test")), elseLoc || after);
      self.explodeStatement(path.get("consequent"));
      if (elseLoc) {
        self.jump(after);
        self.mark(elseLoc);
        self.explodeStatement(path.get("alternate"));
      }
      self.mark(after);
      break;
    case "ReturnStatement":
      self.emitAbruptCompletion({
        type: "return",
        value: self.explodeExpression(path.get("argument"))
      });
      break;
    case "WithStatement":
      throw new Error("WithStatement not supported in generator functions.");
    case "TryStatement":
      after = this.loc();
      var handler = stmt.handler;
      var catchLoc = handler && this.loc();
      var catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);
      var finallyLoc = stmt.finalizer && this.loc();
      var finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);
      var tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);
      self.tryEntries.push(tryEntry);
      self.updateContextPrevLoc(tryEntry.firstLoc);
      self.leapManager.withEntry(tryEntry, function () {
        self.explodeStatement(path.get("block"));
        if (catchLoc) {
          if (finallyLoc) {
            self.jump(finallyLoc);
          } else {
            self.jump(after);
          }
          self.updateContextPrevLoc(self.mark(catchLoc));
          var bodyPath = path.get("handler.body");
          var safeParam = self.makeTempVar();
          self.clearPendingException(tryEntry.firstLoc, safeParam);
          bodyPath.traverse(catchParamVisitor, {
            getSafeParam: function getSafeParam() {
              return t.cloneDeep(safeParam);
            },
            catchParamName: handler.param.name
          });
          self.leapManager.withEntry(catchEntry, function () {
            self.explodeStatement(bodyPath);
          });
        }
        if (finallyLoc) {
          self.updateContextPrevLoc(self.mark(finallyLoc));
          self.leapManager.withEntry(finallyEntry, function () {
            self.explodeStatement(path.get("finalizer"));
          });
          self.emit(t.returnStatement(t.callExpression(self.contextProperty("finish"), [finallyEntry.firstLoc])));
        }
      });
      self.mark(after);
      break;
    case "ThrowStatement":
      self.emit(t.throwStatement(self.explodeExpression(path.get("argument"))));
      break;
    case "ClassDeclaration":
      self.emit(self.explodeClass(path));
      break;
    default:
      throw new Error("unknown Statement of type " + JSON.stringify(stmt.type));
  }
};
var catchParamVisitor = {
  Identifier: function Identifier(path, state) {
    if (path.node.name === state.catchParamName && util.isReference(path)) {
      util.replaceWithOrRemove(path, state.getSafeParam());
    }
  },
  Scope: function Scope(path, state) {
    if (path.scope.hasOwnBinding(state.catchParamName)) {
      path.skip();
    }
  }
};
Ep.emitAbruptCompletion = function (record) {
  if (!isValidCompletion(record)) {
    _assert["default"].ok(false, "invalid completion record: " + JSON.stringify(record));
  }
  _assert["default"].notStrictEqual(record.type, "normal", "normal completions are not abrupt");
  var t = util.getTypes();
  var abruptArgs = [t.stringLiteral(record.type)];
  if (record.type === "break" || record.type === "continue") {
    t.assertLiteral(record.target);
    abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target);
  } else if (record.type === "return" || record.type === "throw") {
    if (record.value) {
      t.assertExpression(record.value);
      abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value);
    }
  }
  this.emit(t.returnStatement(t.callExpression(this.contextProperty("abrupt"), abruptArgs)));
};
function isValidCompletion(record) {
  var type = record.type;
  if (type === "normal") {
    return !hasOwn.call(record, "target");
  }
  if (type === "break" || type === "continue") {
    return !hasOwn.call(record, "value") && util.getTypes().isLiteral(record.target);
  }
  if (type === "return" || type === "throw") {
    return hasOwn.call(record, "value") && !hasOwn.call(record, "target");
  }
  return false;
}

Ep.getUnmarkedCurrentLoc = function () {
  return util.getTypes().numericLiteral(this.listing.length);
};

Ep.updateContextPrevLoc = function (loc) {
  var t = util.getTypes();
  if (loc) {
    t.assertLiteral(loc);
    if (loc.value === -1) {
      loc.value = this.listing.length;
    } else {
      _assert["default"].strictEqual(loc.value, this.listing.length);
    }
  } else {
    loc = this.getUnmarkedCurrentLoc();
  }

  this.emitAssign(this.contextProperty("prev"), loc);
};

Ep.explodeViaTempVar = function (tempVar, childPath, hasLeapingChildren, ignoreChildResult) {
  _assert["default"].ok(!ignoreChildResult || !tempVar, "Ignoring the result of a child expression but forcing it to " + "be assigned to a temporary variable?");
  var t = util.getTypes();
  var result = this.explodeExpression(childPath, ignoreChildResult);
  if (ignoreChildResult) {
  } else if (tempVar || hasLeapingChildren && !t.isLiteral(result)) {
    result = this.emitAssign(tempVar || this.makeTempVar(), result);
  }
  return result;
};
Ep.explodeExpression = function (path, ignoreResult) {
  var t = util.getTypes();
  var expr = path.node;
  if (expr) {
    t.assertExpression(expr);
  } else {
    return expr;
  }
  var self = this;
  var result; // Used optionally by several cases below.
  var after;
  function finish(expr) {
    t.assertExpression(expr);
    if (ignoreResult) {
      self.emit(expr);
    }
    return expr;
  }

  if (!meta.containsLeap(expr)) {
    return finish(expr);
  }

  var hasLeapingChildren = meta.containsLeap.onlyChildren(expr);


  switch (expr.type) {
    case "MemberExpression":
      return finish(t.memberExpression(self.explodeExpression(path.get("object")), expr.computed ? self.explodeViaTempVar(null, path.get("property"), hasLeapingChildren) : expr.property, expr.computed));
    case "CallExpression":
      var calleePath = path.get("callee");
      var argsPath = path.get("arguments");
      var newCallee;
      var newArgs;
      var hasLeapingArgs = argsPath.some(function (argPath) {
        return meta.containsLeap(argPath.node);
      });
      var injectFirstArg = null;
      if (t.isMemberExpression(calleePath.node)) {
        if (hasLeapingArgs) {

          var newObject = self.explodeViaTempVar(
          self.makeTempVar(), calleePath.get("object"), hasLeapingChildren);
          var newProperty = calleePath.node.computed ? self.explodeViaTempVar(null, calleePath.get("property"), hasLeapingChildren) : calleePath.node.property;
          injectFirstArg = newObject;
          newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier("call"), false);
        } else {
          newCallee = self.explodeExpression(calleePath);
        }
      } else {
        newCallee = self.explodeViaTempVar(null, calleePath, hasLeapingChildren);
        if (t.isMemberExpression(newCallee)) {
          newCallee = t.sequenceExpression([t.numericLiteral(0), t.cloneDeep(newCallee)]);
        }
      }
      if (hasLeapingArgs) {
        newArgs = argsPath.map(function (argPath) {
          return self.explodeViaTempVar(null, argPath, hasLeapingChildren);
        });
        if (injectFirstArg) newArgs.unshift(injectFirstArg);
        newArgs = newArgs.map(function (arg) {
          return t.cloneDeep(arg);
        });
      } else {
        newArgs = path.node.arguments;
      }
      return finish(t.callExpression(newCallee, newArgs));
    case "NewExpression":
      return finish(t.newExpression(self.explodeViaTempVar(null, path.get("callee"), hasLeapingChildren), path.get("arguments").map(function (argPath) {
        return self.explodeViaTempVar(null, argPath, hasLeapingChildren);
      })));
    case "ObjectExpression":
      return finish(t.objectExpression(path.get("properties").map(function (propPath) {
        if (propPath.isObjectProperty()) {
          return t.objectProperty(propPath.node.key, self.explodeViaTempVar(null, propPath.get("value"), hasLeapingChildren), propPath.node.computed);
        } else {
          return propPath.node;
        }
      })));
    case "ArrayExpression":
      return finish(t.arrayExpression(path.get("elements").map(function (elemPath) {
        if (!elemPath.node) {
          return null;
        }
        if (elemPath.isSpreadElement()) {
          return t.spreadElement(self.explodeViaTempVar(null, elemPath.get("argument"), hasLeapingChildren));
        } else {
          return self.explodeViaTempVar(null, elemPath, hasLeapingChildren);
        }
      })));
    case "SequenceExpression":
      var lastIndex = expr.expressions.length - 1;
      path.get("expressions").forEach(function (exprPath) {
        if (exprPath.key === lastIndex) {
          result = self.explodeExpression(exprPath, ignoreResult);
        } else {
          self.explodeExpression(exprPath, true);
        }
      });
      return result;
    case "LogicalExpression":
      after = this.loc();
      if (!ignoreResult) {
        result = self.makeTempVar();
      }
      var left = self.explodeViaTempVar(result, path.get("left"), hasLeapingChildren);
      if (expr.operator === "&&") {
        self.jumpIfNot(left, after);
      } else {
        _assert["default"].strictEqual(expr.operator, "||");
        self.jumpIf(left, after);
      }
      self.explodeViaTempVar(result, path.get("right"), hasLeapingChildren, ignoreResult);
      self.mark(after);
      return result;
    case "ConditionalExpression":
      var elseLoc = this.loc();
      after = this.loc();
      var test = self.explodeExpression(path.get("test"));
      self.jumpIfNot(test, elseLoc);
      if (!ignoreResult) {
        result = self.makeTempVar();
      }
      self.explodeViaTempVar(result, path.get("consequent"), hasLeapingChildren, ignoreResult);
      self.jump(after);
      self.mark(elseLoc);
      self.explodeViaTempVar(result, path.get("alternate"), hasLeapingChildren, ignoreResult);
      self.mark(after);
      return result;
    case "UnaryExpression":
      return finish(t.unaryExpression(expr.operator,
      self.explodeExpression(path.get("argument")), !!expr.prefix));
    case "BinaryExpression":
      return finish(t.binaryExpression(expr.operator, self.explodeViaTempVar(null, path.get("left"), hasLeapingChildren), self.explodeViaTempVar(null, path.get("right"), hasLeapingChildren)));
    case "AssignmentExpression":
      if (expr.operator === "=") {
        return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get("left")), self.explodeExpression(path.get("right"))));
      }
      var lhs = self.explodeExpression(path.get("left"));
      var temp = self.emitAssign(self.makeTempVar(), lhs);


      return finish(t.assignmentExpression("=", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get("right")))));
    case "UpdateExpression":
      return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get("argument")), expr.prefix));
    case "YieldExpression":
      after = this.loc();
      var arg = expr.argument && self.explodeExpression(path.get("argument"));
      if (arg && expr.delegate) {
        var _result = self.makeTempVar();
        var _ret = t.returnStatement(t.callExpression(self.contextProperty("delegateYield"), [arg, t.stringLiteral(_result.property.name), after]));
        _ret.loc = expr.loc;
        self.emit(_ret);
        self.mark(after);
        return _result;
      }
      self.emitAssign(self.contextProperty("next"), after);
      var ret = t.returnStatement(t.cloneDeep(arg) || null);
      ret.loc = expr.loc;
      self.emit(ret);
      self.mark(after);
      return self.contextProperty("sent");
    case "ClassExpression":
      return finish(self.explodeClass(path));
    default:
      throw new Error("unknown Expression of type " + JSON.stringify(expr.type));
  }
};
Ep.explodeClass = function (path) {
  var explodingChildren = [];
  if (path.node.superClass) {
    explodingChildren.push(path.get("superClass"));
  }
  path.get("body.body").forEach(function (member) {
    if (member.node.computed) {
      explodingChildren.push(member.get("key"));
    }
  });
  var hasLeapingChildren = explodingChildren.some(function (child) {
    return meta.containsLeap(child);
  });
  for (var i = 0; i < explodingChildren.length; i++) {
    var child = explodingChildren[i];
    var isLast = i === explodingChildren.length - 1;
    if (isLast) {
      child.replaceWith(this.explodeExpression(child));
    } else {
      child.replaceWith(this.explodeViaTempVar(null, child, hasLeapingChildren));
    }
  }
  return path.node;
};